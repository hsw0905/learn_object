## 소극장 티켓 판매

### 시나리오
- 관람객(Audience) : 초대장이 있는 관람객, 없는 관람객, 가방 소지
- 초대장이 있는 관람객 -> 티켓으로 교환 후 입장
- 초대장이 없는 관람객 -> 티켓 구매 후 입장
- (Invitation, Ticket)
---
- 관람객의 소지품 : 초대장, 현금(Amount), 티켓
- 소지품 보관용 가방(Bag)
---
- 매표소(TicketOffice)
- 판매원(TicketSeller) : 매표소에서 초대장 -> 티켓 교환, 혹은 티켓 판매
- 소극장(Theater) : 관람객 입장
---
### 초기 상태
- 소극장 -> 관람객 가방을 열고 초대장 여부 확인
- -> 초대장 있으면? -> 판매원 -> 매표소 -> 보관된 티켓을 관람객의 가방으로 옮김
- -> 초대장 없으면? -> 판매원 -> 관람객의 가방 -> 티켓값 꺼내 -> 매표소 적립 -> 티켓을 관람객 가방 안에 넣음
---
### 초기 상태의 문제점
- 관람객, 판매원이 소극장의 통제를 받는 수동적인 존재
- 하나의 클래스에서 너무 많은 세부사항을 다루고 있다
- 변경사항에 코드가 너무 취약하다
---
### 해결점
- 소극장 : 관람객이 소극장에 입장하기만 하면 된다. 그 외 사항은 정보를 차단한다
- 관람객 : 스스로 가방 안의 현금, 초대장을 처리한다.
- 판매원 : 스스로 매표소의 티켓, 판매 요금을 다룬다.
---
### 의존성
- 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다
- 최소한의 의존성만 유지하고 불필요한 의존성은 제거한다

### 결합도
- 객체 사이의 의존성이 과한 경우 : 결합도가 높다
- 객체들이 합리적인 수준으로 의존 : 결합도가 낮다
- 목표: 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만든다

### 결합도를 낮추고 변경하기 쉬운 코드
- 객체를 인터페이스와 구현으로 나눈다
- 인터페이스만 공개한다
---
### 코드 수정 전
- Theater의 enter 메서드 안에서 
- Audience, TicketSeller로부터 Bag, TicketOffice를 가져와 관람객을 입장시킨다
- Thater의 enter 메서드 == **프로세스(Precess)**
- Audience, TicketSeller, Bag, TicketOffice == **데이터(Data)**
- 프로세스와 데이터를 별도의 모듈에 위치하는 방식 == **절차지향적 프로그래밍**
- 결론: 절차적 프로그래밍 방식으로 작성된 전형적인 의존성 구조
- (모든 처리각 하나의 클래스 안에 위치, 나머지 클래스는 단순히 데이터의 역할)

### 코드 수정 후
- 프로세스의 적절한 단계를 Audience, TicketSeller로 이동
- **(책임(기능)의 이동)**
- 자신의 데이터를 스스로 처리
- 데이터와 프로세스가 동일한 모듈 내부에 위치 == **객체지향 프로그래밍**
---
### 2차 개선
- Bag 캡슐화
- Audience : Bag의 구현이 아닌 인터페이스에만 의존
- TicketOffice 캡슐화
- TicketSeller : TicketOffice의 구현이 아닌 인터페이스에만 의존
---
### 배운 점
- 코드에서 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다? -> 절차적 프로그래밍 방식을 따르고 있을 확률이 높다
- 설계를 어렵게 만드는 주요 요인은 **의존성**이다
- 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 **결합도**를 낮추는 것이다

